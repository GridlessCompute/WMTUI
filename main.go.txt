// package main

// import (
// 	network "WMTUI/Network"
// 	scaner "WMTUI/Scaner"
// 	"fmt"
// 	"os"
// 	"sort"
// 	"sync"

// 	"github.com/charmbracelet/bubbles/table"
// 	"github.com/charmbracelet/bubbles/textinput"
// 	tea "github.com/charmbracelet/bubbletea"
// )

// type status int
// type sortBy int

// const (
// 	MainView status = iota
// 	SelectedView
// 	NewFarmView
// 	FarmSelectionView
// 	FarmCreationView
// )

// const (
// 	Name status = iota
// 	Root
// 	Length
// )

// const (
// 	IPSort sortBy = iota
// 	MACSort
// 	THSort
// 	UPSort
// )

// // WIP
// // type newFarmForm struct {
// // 	Name   textinput.Model
// // 	Root   textinput.Model
// // 	Length textinput.Model
// // }

// // type farmJson struct {
// // 	Name   string `json:"name"`
// // 	Root   string `json:"root"`
// // 	Length string `json:"length"`
// // }

// type tableModel struct {
// 	focused status
// 	tables  []table.Model
// 	// farmSelection   list.Model
// 	loaded          bool
// 	quiting         bool
// 	modelMinersList []network.MinerObj
// 	sortBy          sortBy
// 	// farms           []farmStruct
// }

// type formModel struct {
// 	focused status
// 	Name    textinput.Model
// 	Root    textinput.Model
// 	Length  textinput.Model
// }

// var Models []tea.Model

// // From Functions //
// func NewForm(focused status) *formModel {
// 	form := &formModel{}
// 	form.Name = textinput.New()
// 	form.Name.Focus()
// 	form.Root = textinput.New()
// 	form.Length = textinput.New()
// 	return form
// }

// // Table Functions //

// func New() *tableModel {
// 	return &tableModel{}
// }

// func (t *tableModel) GenerateInitialMiner(scanwg *sync.WaitGroup, popwg *sync.WaitGroup, mainChannel chan network.MinerObj, swg *sync.WaitGroup) {
// 	mnrOChannel := make(chan network.MinerObj, 150)
// 	popChannel := make(chan network.MinerObj, 150)

// 	defer swg.Done()

// 	ips := scaner.Ipgen()

// 	scaner.ScanRange(ips, scanwg, mnrOChannel)
// 	scanwg.Wait()
// 	close(mnrOChannel)

// 	scaner.PopulateRange(mnrOChannel, popwg, popChannel)
// 	popwg.Wait()
// 	close(popChannel)

// 	for mnr := range popChannel {
// 		t.modelMinersList = append(t.modelMinersList, mnr)
// 	}
// }

// func (t *tableModel) GenerateInitialMinerList() {
// 	var wg1 sync.WaitGroup
// 	var wg2 sync.WaitGroup
// 	var swg sync.WaitGroup

// 	channel := make(chan network.MinerObj, 150)

// 	swg.Add(1)

// 	go t.GenerateInitialMiner(&wg1, &wg2, channel, &swg)

// 	swg.Wait()

// 	close(channel)
// }

// func (t *tableModel) generateRows() {
// 	var rows []table.Row

// 	for _, miner := range t.modelMinersList {
// 		rows = append(rows, table.Row{
// 			miner.Miner.Ip,
// 			miner.Miner.Mac,
// 			miner.Miner.Errcode,
// 			fmt.Sprint(miner.Miner.UpTime),
// 			fmt.Sprint(miner.Miner.Hrrt),
// 			fmt.Sprint(miner.Miner.Wt),
// 			fmt.Sprint(miner.Miner.W),
// 			fmt.Sprint(miner.Miner.Limit),
// 			miner.Miner.AcvtivePool,
// 		})
// 	}

// 	t.tables[MainView].SetRows(rows)
// }

// // WIP
// // func (t *tableModel) refreshMainTable() {
// // 	var wg sync.WaitGroup
// // 	var newMinerChannel chan network.MinerObj
// // 	var oldMinerSlice []network.MinerObj
// // 	var newMinerSlice []network.MinerObj

// // 	oldMinerSlice = append(oldMinerSlice, t.modelMinersList...)

// // 	fmt.Println(oldMinerSlice)

// // 	fmt.Println("Getting miner date")
// // 	scaner.PopulateRangeSlice(oldMinerSlice, &wg, newMinerChannel)
// // 	fmt.Println("waiting")
// // 	// Waits forever but only in this loop ?
// // 	wg.Wait()
// // 	fmt.Println("closing")
// // 	close(newMinerChannel)

// // 	fmt.Println("done getting miner data")

// // 	for miner := range newMinerChannel {
// // 		fmt.Println("loop 2")
// // 		newMinerSlice = append(newMinerSlice, miner)
// // 	}

// // 	t.modelMinersList = t.modelMinersList[:0]
// // 	t.modelMinersList = append(t.modelMinersList, newMinerSlice...)
// // }

// func (m *tableModel) initTables() {
// 	columns := []table.Column{
// 		{Title: "IP", Width: 15},
// 		{Title: "Mac", Width: 20},
// 		{Title: "Error Code", Width: 25},
// 		{Title: "Up time", Width: 10},
// 		{Title: "Hrrt", Width: 10},
// 		{Title: "WT", Width: 10},
// 		{Title: "W", Width: 10},
// 		{Title: "Limit", Width: 10},
// 		{Title: "Pool 1", Width: 50},
// 	}

// 	// m.GenerateInitialMinerList()
// 	// rows := generateRows(m.minersChannel)

// 	defaultTable := table.New(table.WithColumns(columns), table.WithHeight(35))

// 	m.tables = []table.Model{defaultTable, defaultTable}
// 	// m.tables[MainView].SetRows(rows)
// 	// m.tables[MainView].Focus()
// 	// fmt.Println(m.tables[MainView].Focused())
// }

// func (m *tableModel) sortByIP() {
// 	sort.Slice(m.modelMinersList, func(i, j int) bool {
// 		return m.modelMinersList[i].Miner.Ip < m.modelMinersList[j].Miner.Ip
// 	})
// }

// func (m *tableModel) sortByMAC() {
// 	sort.Slice(m.modelMinersList, func(i, j int) bool {
// 		return m.modelMinersList[i].Miner.Mac < m.modelMinersList[j].Miner.Mac
// 	})
// }

// func (m *tableModel) sortByTH() {
// 	sort.Slice(m.modelMinersList, func(i, j int) bool {
// 		return m.modelMinersList[i].Miner.Hrrt < m.modelMinersList[j].Miner.Hrrt
// 	})
// }

// func (m *tableModel) sortByUP() {
// 	sort.Slice(m.modelMinersList, func(i, j int) bool {
// 		return m.modelMinersList[i].Miner.UpTime < m.modelMinersList[j].Miner.UpTime
// 	})
// }

// func (m *tableModel) TransferRow() ([]table.Row, []table.Row) {
// 	var tableH table.Model
// 	var newRowsV []table.Row
// 	var newRowsH []table.Row

// 	tableV := m.tables[m.focused]

// 	if m.focused == MainView {
// 		tableH = m.tables[SelectedView]
// 	} else {
// 		tableH = m.tables[MainView]
// 	}

// 	rowsV := tableV.Rows()
// 	newRowsH = append(newRowsH, tableH.Rows()...)

// 	mac := m.tables[m.focused].SelectedRow()[1]

// 	for _, r := range rowsV {
// 		if r[1] != mac {
// 			newRowsV = append(newRowsV, r)
// 			newRowsH = append(newRowsH, r)
// 		}
// 	}

// 	return newRowsV, newRowsH
// }

// func (m tableModel) Init() tea.Cmd {
// 	return textinput.Blink
// }

// func (m tableModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
// 	var cmd tea.Cmd
// 	var cmds []tea.Cmd
// 	switch msg := msg.(type) {
// 	case tea.WindowSizeMsg:
// 		if !m.loaded {
// 			fmt.Println("Initializing Form")
// 			//m.NewForm()
// 			fmt.Println("Initializing Tables")
// 			m.initTables()
// 			fmt.Println("Getting Farms")
// 			//m.getFarmsFromJson()
// 			fmt.Println("Initializing Farms")
// 			//m.initFarms(msg.Width, msg.Height)
// 			fmt.Println("Getting Miners")
// 			m.GenerateInitialMinerList()
// 			fmt.Println("Sorting Miners")
// 			m.sortBy = IPSort
// 			m.sortByIP()
// 			fmt.Println("Generating rows")
// 			m.generateRows()
// 			m.quiting = false
// 			m.loaded = true
// 		}
// 	case tea.KeyMsg:
// 		switch msg.String() {
// 		case "q", "ctrl+c":
// 			m.quiting = true
// 			return m, tea.Quit
// 		}
// 	}
// 	switch m.focused {
// 	case MainView:
// 		switch msg := msg.(type) {
// 		case tea.KeyMsg:
// 			switch msg.String() {
// 			case "tab":
// 				m.focused = SelectedView
// 			case "enter":
// 				rowsV, rowsH := m.TransferRow()

// 				if m.focused == MainView {
// 					m.tables[MainView].SetRows(rowsV)
// 					m.tables[SelectedView].SetRows(rowsH)
// 				} else {
// 					m.tables[MainView].SetRows(rowsH)
// 					m.tables[SelectedView].SetRows(rowsV)
// 				}
// 			case "up":
// 				m.tables[m.focused].MoveUp(1)
// 			case "down":
// 				m.tables[m.focused].MoveDown(1)
// 			case "r":
// 				// TODO: Implement refresh -> Half implemented, some issue with wg.wait in refershMainTable() seeming to wait forever

// 				//m.refreshMainTable()
// 				//m.generateRows()
// 			case "`":
// 				// TODO: Implement Sort -> 90% done IPSort is a bit janky due to the nature of strings
// 				switch m.sortBy {
// 				case IPSort:
// 					m.sortBy = MACSort
// 					m.sortByMAC()
// 					m.generateRows()
// 				case MACSort:
// 					m.sortBy = THSort
// 					m.sortByTH()
// 					m.generateRows()
// 				case THSort:
// 					m.sortBy = UPSort
// 					m.sortByUP()
// 					m.generateRows()
// 				case UPSort:
// 					m.sortBy = IPSort
// 					m.sortByIP()
// 					m.generateRows()
// 				}
// 			case "n":
// 				// TODO: Implemet New Farm textInput.Model maybe that runs through multiple prompts
// 				// TODO: Store farms in a json file
// 				m.focused = NewFarmView
// 			case "f":
// 				m.focused = FarmSelectionView
// 			}
// 		}
// 	case SelectedView:
// 		switch msg := msg.(type) {
// 		case tea.KeyMsg:
// 			switch msg.String() {
// 			case "tab":
// 				m.focused = MainView
// 			case "up":
// 				m.tables[m.focused].MoveUp(1)
// 			case "down":
// 				m.tables[m.focused].MoveDown(1)
// 			case "r":
// 				// TODO: Implement Reboot
// 			case "s":
// 				// TODO: Implement Sleep
// 			case "p":
// 				// TODO: Implement Pools
// 			case "l":
// 				// TODO: Implement Power Limit
// 			case "w":
// 				// TODO: Implement Wake
// 			case "f":
// 				// TODO: Implement Fastboot toggle
// 			}
// 		}
// 	}

// 	// return m, cmd
// 	cmds = append(cmds, cmd)
// 	return m, tea.Batch(cmds...)
// }

// func (t tableModel) View() string {
// 	if t.quiting {
// 		return ""
// 	}
// 	if t.loaded {
// 		switch t.focused {
// 		case MainView:
// 			return t.tables[MainView].View()
// 		default:
// 			return t.tables[SelectedView].View()
// 		}
// 	} else {
// 		return "Scanning..."
// 	}
// }

// func main() {
// 	Models = []tea.Model{New()}
// 	m := models[mainM]
// 	p := tea.NewProgram(m)

// 	if _, err := tea.NewProgram(m).Run(); err != nil {
// 		fmt.Println("Error running program: ", err)
// 		os.Exit(1)
// 	}
// }
